{"main.ts":"import { bootstrapApplication } from '@angular/platform-browser'; \n\nimport { appConfig } from './app/app.config'; \n\nimport { AppComponent } from './app.component';\n\nbootstrapApplication(AppComponent, appConfig).catch((err) => console.error(err));","angular.json":"{\n    \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\",\n    \"version\": 1,\n    \"newProjectRoot\": \"projects\",\n    \"projects\": {\n      \"demo\": {\n        \"root\": \"\",\n        \"sourceRoot\": \"\",\n        \"projectType\": \"application\",\n        \"prefix\": \"app\",\n        \"schematics\": {},\n        \"architect\": {\n          \"build\": {\n            \"builder\": \"@angular-devkit/build-angular:browser\",\n            \"options\": {\n              \"outputPath\": \"dist/demo\",\n              \"index\": \"index.html\",\n              \"main\": \"main.ts\",\n              \"polyfills\": \"polyfills.ts\",\n              \"tsConfig\": \"tsconfig.app.json\",\n              \"assets\": [\n                \"favicon.ico\",\n                \"assets\"\n              ],\n              \"styles\": [\n                \n              ],\n              \"scripts\": []\n            },\n            \"configurations\": {\n              \"production\": {\n                \"fileReplacements\": [\n                  {\n                    \"replace\": \"src/environments/environment.ts\",\n                    \"with\": \"src/environments/environment.prod.ts\"\n                  }\n                ],\n                \"optimization\": true,\n                \"outputHashing\": \"all\",\n                \"sourceMap\": false,\n                \"extractCss\": true,\n                \"namedChunks\": false,\n                \"aot\": true,\n                \"extractLicenses\": true,\n                \"vendorChunk\": false,\n                \"buildOptimizer\": true\n              }\n            }\n          },\n          \"serve\": {\n            \"builder\": \"@angular-devkit/build-angular:dev-server\",\n            \"options\": {\n              \"browserTarget\": \"demo:build\"\n            },\n            \"configurations\": {\n              \"production\": {\n                \"browserTarget\": \"demo:build:production\"\n              }\n            }\n          },\n          \"extract-i18n\": {\n            \"builder\": \"@angular-devkit/build-angular:extract-i18n\",\n            \"options\": {\n              \"browserTarget\": \"demo:build\"\n            }\n          },\n          \"test\": {\n            \"builder\": \"@angular-devkit/build-angular:karma\",\n            \"options\": {\n              \"main\": \"src/test.ts\",\n              \"polyfills\": \"src/polyfills.ts\",\n              \"tsConfig\": \"src/tsconfig.spec.json\",\n              \"karmaConfig\": \"src/karma.conf.js\",\n              \"styles\": [\n                \"styles.css\"\n              ],\n              \"scripts\": [],\n              \"assets\": [\n                \"src/favicon.ico\",\n                \"src/assets\"\n              ]\n            }\n          },\n          \"lint\": {\n            \"builder\": \"@angular-devkit/build-angular:tslint\",\n            \"options\": {\n              \"tsConfig\": [\n                \"src/tsconfig.app.json\",\n                \"src/tsconfig.spec.json\"\n              ],\n              \"exclude\": [\n                \"**/node_modules/**\"\n              ]\n            }\n          }\n        }\n      }\n    },\n    \"defaultProject\": \"demo\"\n  }\n  \n","app.component.ts":"import { AfterViewInit, Component, ElementRef, ViewChild, ViewEncapsulation } from '@angular/core';\nimport {\n  DiagramComponent,\n  NodeModel,\n  ConnectorModel,\n  UserHandleModel,\n  NodeConstraints,\n  DiagramTools,\n  Diagram,\n  BpmnDiagrams,\n  UndoRedo,\n  DiagramModule,\n  ScrollSettingsModel,\n  SymbolPaletteComponent,\n  SymbolInfo,\n  SymbolPaletteModule,\n  SymbolPalette,\n} from '@syncfusion/ej2-angular-diagrams';\n\nimport { ToolbarComponent, ToolbarModule } from '@syncfusion/ej2-angular-navigations';\n\nimport { SwitchComponent } from '@syncfusion/ej2-angular-buttons';\nimport { TooltipComponent, TooltipModule } from '@syncfusion/ej2-angular-popups';\nimport { SwitchModule } from '@syncfusion/ej2-angular-buttons';\n\nDiagram.Inject(UndoRedo, BpmnDiagrams);\nSymbolPalette.Inject(BpmnDiagrams);\n\n@Component({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  encapsulation: ViewEncapsulation.None,\n  standalone: true,\n  // Importing necessary components\n  imports: [ ToolbarModule, TooltipModule, SwitchModule, DiagramModule,  SymbolPaletteModule]\n})\nexport class AppComponent {\n  @ViewChild('diagram')\n  public diagram!: DiagramComponent;\n  @ViewChild('Diagramtoolbar')\n  public toolbar!: ToolbarComponent;\n  @ViewChild('symbolPalette')\n  public symbolPalette!: SymbolPaletteComponent;\n  @ViewChild('toggleSwitch')\n  public toggleSwitch!: SwitchComponent;\n  @ViewChild('switchTooltip')\n  public switchTooltip!: TooltipComponent;\n  @ViewChild('fileInput', { static: false })\n  fileInput!: ElementRef<HTMLInputElement>;\n  @ViewChild('tooltip', { static: false }) tooltip!: TooltipComponent;\n  @ViewChild('editLabel') editLabel!: ElementRef<HTMLElement>;\n  constructor() {\n  }\n\n  isEditMode: boolean = false;\n  ngAfterViewInit(): void {\n    this.applyModeState(this.isEditMode);\n    this.tooltipContent = this.isEditMode ? 'Disable Editing' : 'Enable Editing';\n  }\n  public tools: DiagramTools = DiagramTools.ZoomPan;\n  public scrollSettings: ScrollSettingsModel = {\n    scrollLimit: \"Infinity\", canAutoScroll: true\n  };\n  public flowTimeOut1: any;\n  public flowTimeOut2: any;\n  public isPaused: boolean = false;\n  public animationIntervals: any[] = [];\n  public connectorBeforeAnimationColor: string = '#B0B0B0';\n  public connectorDuringAnimationColor: string = \"#FF7F50\";\n  public connectorAfterAnimationColor: string = \"green\";\n  public connectorAnnotationColor: string = \"#32CD32\";\n  public nodeStrokeBeforeAnimationColor: string = \"black\";\n  public nodeStrokeAfterAnimationColor: string = \"green\";\n  public tooltipContent: string = 'Enable Editing';\n  public nodes: NodeModel[] = [\n    {\n      id: \"start\",\n      offsetX: 100,\n      offsetY: 380,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Event\",\n        event: { event: \"Start\", trigger: \"None\" },\n      },\n      annotations: [{ content: \"Start\" }],\n    },\n    {\n      id: \"liquidInput\",\n      offsetX: 300,\n      offsetY: 280,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Liquid Input\" }],\n    },\n    {\n      id: \"dryInput\",\n      offsetX: 300,\n      offsetY: 480,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Dry Input\" }],\n    },\n    {\n      id: \"condensed\",\n      offsetX: 500,\n      offsetY: 180,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Condensed\" }],\n    },\n    {\n      id: \"cream\",\n      offsetX: 500,\n      offsetY: 260,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Cream\" }],\n    },\n    {\n      id: \"caneSugar\",\n      offsetX: 500,\n      offsetY: 340,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Cane Sugar\" }],\n    },\n    {\n      id: \"water\",\n      offsetX: 500,\n      offsetY: 420,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Water\" }],\n    },\n    {\n      id: \"ingredients\",\n      offsetX: 500,\n      offsetY: 500,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Ingredients\" }],\n    },\n    {\n      id: \"flavour\",\n      offsetX: 500,\n      offsetY: 580,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Flavour\" }],\n    },\n    {\n      id: \"fruitsAndNuts\",\n      offsetX: 500,\n      offsetY: 660,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Fruits and Nuts\" }],\n    },\n    {\n      id: \"blending\",\n      offsetX: 700,\n      offsetY: 380,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Blending\" }],\n    },\n    {\n      id: \"coolingAging\",\n      offsetX: 840,\n      offsetY: 380,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Cooling/Aging\" }],\n    },\n    {\n      id: \"packaging\",\n      offsetX: 980,\n      offsetY: 380,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Packaging\" }],\n    },\n    {\n      id: \"storageDistribution\",\n      width: 140,\n      offsetX: 1130,\n      offsetY: 380,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Activity\",\n        activity: { activity: \"Task\" },\n      },\n      annotations: [{ content: \"Storage/Distribution\" }],\n    },\n    {\n      id: \"end\",\n      offsetX: 1260,\n      offsetY: 380,\n      shape: {\n        type: \"Bpmn\",\n        shape: \"Event\",\n        event: { event: \"End\", trigger: \"None\" },\n      },\n      annotations: [{ content: \"End\" }],\n    },\n  ];\n\n  public connectors: ConnectorModel[] = [\n    { id: \"c1\", sourceID: \"start\", targetID: \"liquidInput\" },\n    { id: \"c2\", sourceID: \"start\", targetID: \"dryInput\" },\n    { id: \"c3\", sourceID: \"liquidInput\", targetID: \"condensed\" },\n    { id: \"c4\", sourceID: \"liquidInput\", targetID: \"cream\" },\n    { id: \"c5\", sourceID: \"liquidInput\", targetID: \"caneSugar\" },\n    { id: \"c6\", sourceID: \"liquidInput\", targetID: \"water\" },\n    { id: \"c7\", sourceID: \"liquidInput\", targetID: \"ingredients\" },\n    {\n      id: \"c8\",\n      sourceID: \"dryInput\",\n      targetID: \"flavour\",\n    },\n    {\n      id: \"c9\",\n      sourceID: \"dryInput\",\n      targetID: \"fruitsAndNuts\",\n    },\n    { id: \"c10\", sourceID: \"condensed\", targetID: \"blending\" },\n    { id: \"c11\", sourceID: \"cream\", targetID: \"blending\" },\n    { id: \"c12\", sourceID: \"caneSugar\", targetID: \"blending\" },\n    { id: \"c13\", sourceID: \"water\", targetID: \"blending\" },\n    { id: \"c14\", sourceID: \"ingredients\", targetID: \"blending\" },\n    { id: \"c15\", sourceID: \"flavour\", targetID: \"blending\" },\n    { id: \"c16\", sourceID: \"fruitsAndNuts\", targetID: \"blending\" },\n    { id: \"c17\", sourceID: \"blending\", targetID: \"coolingAging\" },\n    { id: \"c18\", sourceID: \"coolingAging\", targetID: \"packaging\" },\n    { id: \"c19\", sourceID: \"packaging\", targetID: \"storageDistribution\" },\n    { id: \"c20\", sourceID: \"storageDistribution\", targetID: \"end\" },\n  ];\n\n  // Node defaults\n  public getNodeDefaults(node: NodeModel): NodeModel {\n    // restrict rotation and hide thumbs\n    node.constraints =\n      (NodeConstraints.Default & ~NodeConstraints.Rotate) |\n      NodeConstraints.HideThumbs;\n    // Set default width and height\n    const dimensions: any = {\n      Event: { width: 60, height: 60 },\n      Gateway: { width: 90, height: 70 },\n      Activity: { width: 90, height: 50 },\n    };\n\n    const shapeType = (node.shape as any).shape;\n    if (!node.width) node.width = dimensions[shapeType].width;\n    if (!node.height) node.height = dimensions[shapeType].height;\n    return node;\n  }\n\n  public getConnectorDefaults: Function = this.connectorDefaults.bind(this);\n\n  // Connector defaults\n  public connectorDefaults(connector: ConnectorModel): ConnectorModel {\n    // Configure the connector with a straight type\n    connector.type = \"Straight\";\n\n    // connector initial color style, before animation\n    connector.style.strokeColor =\n      connector.targetDecorator.style.strokeColor =\n      connector.targetDecorator.style.fill =\n      this.connectorBeforeAnimationColor;\n\n    // connector annotation, that will be animated during the workflow animation\n    connector.annotations = [\n      {\n        content: \"\",\n        height: 16,\n        width: 16,\n        offset: 0,\n        style: { fill: \"transparent\", fontSize: 24 },\n      },\n    ];\n    return connector;\n  }\n\n  // User handles\n  public selectedItems = {\n    userHandles: [\n      {\n        name: 'delete',\n        pathData:\n          'M0.97,3.04 L12.78,3.04 L12.78,12.21 C12.78,12.64,12.59,13,12.2,13.3 C11.82,13.6,11.35,13.75,10.8,13.75 L2.95,13.75 C2.4,13.75,1.93,13.6,1.55,13.3 C1.16,13,0.97,12.64,0.97,12.21 Z M4.43,0 L9.32,0 L10.34,0.75 L13.75,0.75 L13.75,2.29 L0,2.29 L0,0.75 L3.41,0.75 Z',\n        tooltip: { content: 'Delete Node' },\n        side: 'Bottom',\n        offset: 0.5,\n        margin: { bottom: 5 },\n        disableConnectors: true,\n      },\n      {\n        name: 'drawConnector',\n        pathData:\n          'M6.09,0 L13.75,6.88 L6.09,13.75 L6.09,9.64 L0,9.64 L0,4.11 L6.09,4.11 Z',\n        tooltip: { content: 'Draw Connector' },\n        side: 'Right',\n        offset: 0.5,\n        margin: { right: 5 },\n        disableConnectors: true,\n      },\n      {\n        name: 'stopAnimation',\n        pathData: 'M4.75,0.75 L9.25,0.75 L9.25,9.25 L4.75,9.25 Z',\n        tooltip: { content: 'Enable Animation' },\n        disableNodes: true,\n      },\n    ] as UserHandleModel[],\n  };\n\n  public onCreated(): void {\n    this.diagram.fitToPage();\n  }\n\n  // Dynamically updates the stopAnimation user handle icon and tooltip based on the selected connector's state\n  public onSelectionChange(args: any): void {\n    if (args.state !== \"Changed\") return;\n    const connector = this.diagram.selectedItems.connectors[0];\n    let handle = null;\n    for (let i = 0; i < this.diagram.selectedItems.userHandles.length; i++) {\n      if (this.diagram.selectedItems.userHandles[i].name === \"stopAnimation\") {\n        handle = this.diagram.selectedItems.userHandles[i];\n        break;\n      }\n    }\n    if (connector && handle) {\n      const isStopped =\n        (connector.addInfo as any) && (connector.addInfo as any).stopAnimation === true;\n\n      handle.pathData = isStopped\n        ? \"M2,0 L10,8 L2,16 L2,0 Z\" // Play icon (start animation)\n        : \"M5.25,1.25 L8.75,1.25 L8.75,8.75 L5.25,8.75 Z\"; // Stop icon\n\n      handle.tooltip.content = isStopped\n        ? \"Enable Animation\"\n        : \"Disable Animation\";\n\n      handle.visible = true;\n    } else if (handle) {\n      handle.visible = false;\n    }\n  }\n\n  // User handle functionality\n  public onUserHandleMouseDown(args: any): void {\n    const handleName = args.element.name;\n\n    switch (handleName) {\n      case 'delete':\n        this.diagram.remove(this.diagram.selectedItems.nodes[0]);\n        break;\n\n      case 'drawConnector':\n        const sourceNode = this.diagram.selectedItems.nodes[0];\n        if (!sourceNode) return;\n        this.diagram.drawingObject = { type: 'Straight', sourceID: sourceNode.id };\n        this.diagram.tool = DiagramTools.DrawOnce;\n        break;\n\n      case 'stopAnimation':\n        const connector = this.diagram.selectedItems.connectors[0];\n        if (connector) {\n          if (!connector.addInfo) (connector.addInfo as any) = {};\n          (connector.addInfo as any).stopAnimation = !(connector.addInfo as any).stopAnimation;\n\n          // Update path and tooltip\n          const handle = this.diagram.selectedItems.userHandles.find((h: any) => h.name === 'stopAnimation');\n          if (handle) {\n            const isStopped = (connector.addInfo as any).stopAnimation;\n\n            handle.pathData = isStopped\n              ? 'M2,0 L10,8 L2,16 L2,0 Z'  // Play icon\n              : 'M4.75,0.75 L9.25,0.75 L9.25,9.25 L4.75,9.25 Z';  // Stop icon\n\n            handle.tooltip.content = isStopped ? 'Enable Animation' : 'Disable Animation';\n          }\n        }\n        break;\n    }\n  }\n\n  // Workflow animation\n  public startWorkflow() {\n    // PAUSE state if running\n    if (!this.isPaused && this.animationIntervals.length) {\n      this.isPaused = true;\n      this.updateExecuteButton(\"Resume\");\n      this.clearAnimationIntervals();\n      return;\n    }\n\n    // RESUME state if paused\n    if (this.isPaused) {\n      this.isPaused = false;\n      this.updateExecuteButton(\"Pause\");\n      this.resumeWorkflow();\n      return;\n    }\n\n    // EXECUTE state to start from start\n    this.isPaused = false;\n    this.resetWorkflow();\n    this.updateExecuteButton(\"Pause\");\n\n    // find the \"start\" nodes in the diagram, as animation only works from \"start\" nodes\n    const startNodes = this.diagram.nodes.filter((node: any) => {\n      return (\n        node.shape &&\n        node.shape.type === \"Bpmn\" &&\n        node.shape.shape === \"Event\" &&\n        node.shape.event.event === \"Start\"\n      );\n    });\n\n    if (startNodes.length === 0) {\n      console.error(\"No start nodes found.\");\n      return;\n    }\n\n    startNodes.forEach((startNode: any) => {\n      this.animateNode(startNode.id);\n    });\n  }\n\n  // Resume Workflow animation from the last paused state\n  public resumeWorkflow() {\n    this.diagram.connectors.forEach((connector: any) => {\n      // Retrieve the last annotation of the connector\n      const lastAnn = connector.annotations[connector.annotations.length - 1];\n      // Check if the annotation offset is within the animation range\n      if (lastAnn && lastAnn.offset > 0 && lastAnn.offset < 0.9) {\n        // Restore the annotations that need to be visible\n        lastAnn.content = \"●\";\n        if (lastAnn.style) lastAnn.style.color = this.connectorAnnotationColor;\n\n        // Get the source node of the connector and check if it s a start event node\n        const sourceNode = this.diagram.getObject(connector.sourceID);\n        const isStartNode =\n          sourceNode &&\n          (sourceNode as any).shape &&\n          (sourceNode as any).shape.type === \"Bpmn\" &&\n          (sourceNode as any).shape.shape === \"Event\" &&\n          (sourceNode as any).shape.event &&\n          (sourceNode as any).shape.event.event === \"Start\";\n\n        // If the source node is a start node or already completed node, continue the animation\n        if (\n          isStartNode ||\n          (sourceNode && (sourceNode as any).style.strokeColor === this.nodeStrokeAfterAnimationColor)\n        ) {\n          // Animate the connector and the target node\n          this.animateConnector(connector, (targetId: string) => {\n            const targetNode = this.diagram.getObject(targetId);\n            if (targetNode) {\n              this.createLoadingAnimation(targetNode);\n              setTimeout(() => {\n                this.completeNodeAnimation(targetNode);\n                this.animateNode(targetId);\n              }, 1000);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  // Function to animate a node and its connected nodes\n  public animateNode(nodeId: string): void {\n    // Filter connectors originating from the node\n    const currentConnectors = this.diagram.connectors.filter((conn: any) => conn.sourceID === nodeId);\n    currentConnectors.forEach((connector: any) => {\n      // Check if additional info contains \"stopAnimation\"\n      if (!(connector.addInfo && connector.addInfo.stopAnimation === true)) {\n        this.animateConnector(connector, (targetNodeId: string) => {\n          const targetNode = this.diagram.getObject(targetNodeId);\n          // Start loading animation for the target node\n          if (targetNode) {\n            this.createLoadingAnimation(targetNode);\n            // Hide all loading indicators\n            this.flowTimeOut1 = setTimeout(() => {\n              document.querySelectorAll(\".Diagram-loading-indicator\").forEach((el: any) => el.style.display = \"none\");\n              document.querySelectorAll(\".Diagramtick\").forEach((el: any) => el.style.display = \"block\");\n              (targetNode as any).style.strokeColor = this.nodeStrokeAfterAnimationColor;\n              this.diagram.dataBind();\n              // Check if the target node is a BPMN \"End\" event node\n              if ((targetNode as any).shape && (targetNode as any).shape.type === \"Bpmn\" && (targetNode as any).shape.shape === \"Event\" && (targetNode as any).shape.event && (targetNode as any).shape.event.event === \"End\") {\n                // Reset toolbar for new execution\n                this.updateExecuteButton(\"Execute\");\n                this.animationIntervals.length = 0;\n              } else {\n                // Recursively animate connected nodes\n                this.animateNode(targetNodeId);\n              }\n            }, 1000);\n          }\n        });\n      }\n    });\n  }\n\n  // Function to animate a connector and execute a callback upon completion\n  public animateConnector(connector: any, callback: Function): void {\n    const lastAnn = connector.annotations[connector.annotations.length - 1];\n    lastAnn.offset = lastAnn.offset || 0.02; // Initialize or set the offset\n    lastAnn.content = \"●\"; // Set visual marker, to show the flow\n    lastAnn.style.color = this.connectorAnnotationColor; // Set annotation marker color\n    this.diagram.dataBind();\n    // Start interval to animate the connector\n    const flowInterval = setInterval(() => {\n      if (this.isPaused) {\n        return; // Pause animation if the workflow is paused\n      }\n      // Continue animation if the offset hasn't reached the end\n      if (lastAnn.offset < 0.9) {\n        lastAnn.offset += 0.025;\n        connector.style.strokeColor = connector.targetDecorator.style.strokeColor = connector.targetDecorator.style.fill = this.connectorDuringAnimationColor; // Change color during animation\n        this.diagram.dataBind();\n      } else {\n        // Animation complete, clean up and execute the callback\n        clearInterval(flowInterval);\n        lastAnn.style.color = \"transparent\";\n        connector.style.strokeColor = connector.targetDecorator.style.strokeColor = connector.targetDecorator.style.fill = this.connectorAfterAnimationColor; // Set after animation color for connector\n        this.diagram.dataBind();\n        callback(connector.targetID); // Execute callback with target node ID\n      }\n    }, 120); // Interval of 120ms for the animation steps\n\n    // Add the interval to the list of active animations\n    this.animationIntervals.push(flowInterval);\n  }\n\n  // Function to create and add a loading animation annotation to a node\n  public createLoadingAnimation(targetNode: any): void {\n    if (!targetNode || !targetNode.annotations) {\n      return;\n    }\n    // HTML template for the loading animation and a hidden tick indicator\n    const htmlTemplate = '<div style=\"display: flex; flex-direction: column; align-items: flex-start; justify-content: flex-start; margin-left: -3px; margin-top: -3px;\"><div class=\"Diagram-loading-indicator\"></div><div class=\"Diagramtick\" style=\"display: none;\"><i class=\"e-icons e-check\"></i></div></div>';\n    // adding annotation with the template to the node\n    const annotation: any = {\n      template: htmlTemplate,\n      offset: { x: 0, y: 0 },\n      verticalAlignment: \"Top\",\n      horizontalAlignment: \"Left\",\n      style: { fill: \"transparent\" }\n    };\n    this.diagram.addLabels(targetNode, [annotation]);\n  }\n\n  // Function to show complete status for the given node\n  public completeNodeAnimation(node: any): void {\n    // Hide all loading indicators\n    document.querySelectorAll(\".Diagram-loading-indicator\").forEach((el: any) => el.style.display = \"none\");\n    // Display all tick elements as visible\n    document.querySelectorAll(\".Diagramtick\").forEach((el: any) => el.style.display = \"block\");\n    // Update the stroke color for the node to indicate completion\n    if (node.style) {\n      node.style.strokeColor = this.nodeStrokeAfterAnimationColor;\n    }\n    // Update the diagram to reflect changes\n    this.diagram.dataBind();\n  }\n\n  public resetWorkflow(): void {\n    // Set pause state to false\n    this.isPaused = false;\n    // clear any existing timeouts\n    clearTimeout(this.flowTimeOut1);\n    clearTimeout(this.flowTimeOut2);\n    // Clear any running animation intervals\n    this.clearAnimationIntervals();\n    // Remove all custom animations and tick indicators\n    document.querySelectorAll(\".Diagram-loading-indicator, .Diagramtick\").forEach((el: any) => el.remove());\n    // Restore all nodes to their default styles\n    this.diagram.nodes.forEach((node: any) => {\n      if (node.style) node.style.strokeColor = this.nodeStrokeBeforeAnimationColor;\n    });\n    // Restore all connectors to their default styles\n    this.diagram.connectors.forEach((connector: any) => {\n      connector.style.strokeColor = connector.targetDecorator.style.strokeColor = connector.targetDecorator.style.fill = this.connectorBeforeAnimationColor;\n      // Reset connector annotations to initial state\n      connector.annotations.forEach((ann: any) => {\n        ann.offset = 0;\n        ann.content = \"\";\n        ann.style.color = this.connectorAnnotationColor;\n      });\n    });\n    this.diagram.dataBind();\n  }\n\n  // Function to clear all active animation intervals\n  public clearAnimationIntervals() {\n    // Stop all timers stored in animationIntervals\n    this.animationIntervals.forEach(clearInterval);\n    // Reset the array to remove all interval references\n    this.animationIntervals.length = 0;\n  }\n\n  // Hidden file input for opening json files\n  onFileChange(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    const file = input.files?.[0];\n    if (!file) return;\n\n    const reader = new FileReader();\n    reader.onload = (e: ProgressEvent<FileReader>) => {\n      try {\n        const json = JSON.parse(e.target!.result as string);\n        this.diagram.loadDiagram(json);\n        this.updateExecuteButton('Execute');\n        this.clearAnimationIntervals();\n        this.diagram.tool = DiagramTools.ZoomPan;\n      } catch (err) {\n        console.error('Invalid JSON file', err);\n      } finally {\n        input.value = ''; // Clear file input\n      }\n       this.diagram.fitToPage();\n    };\n    reader.readAsText(file);\n  }\n\n  // Update the execute button's text and tooltip based on the workflow state\n  public updateExecuteButton(state: 'Execute' | 'Pause' | 'Resume'): void {\n    const btn = this.toolbar.items[4];\n    const states = {\n      Pause: {\n        id: \"Pause\",\n        text: \"Pause\",\n        tooltipText: \"Pause Workflow\",\n        prefixIcon: \"e-icons e-pause\",\n      },\n      Resume: {\n        id: \"Resume\",\n        text: \"Resume\",\n        tooltipText: \"Resume Workflow\",\n        prefixIcon: \"e-icons e-play\",\n      },\n      Execute: {\n        id: \"Execute\",\n        text: \"Execute\",\n        tooltipText: \"Start Workflow\",\n        prefixIcon: \"e-icons e-play\",\n      },\n    };\n    Object.assign(btn, states[state] || states.Execute);\n  }\n\n  public onToolbarClick(args: any): void {\n    const diagram = this.diagram;\n\n    switch (args.item.id) {\n      case 'New':\n        this.updateExecuteButton('Execute');\n        this.clearAnimationIntervals();\n        diagram.clear();\n        break;\n      case 'Open':\n        this.fileInput.nativeElement.click();\n        break;\n      case 'Save':\n        this.saveDiagram();\n        break;\n      case 'Execute':\n      case 'Pause':\n      case 'Resume':\n        diagram.clearSelection();\n        this.startWorkflow();\n        break;\n      case 'Reset':\n        this.resetWorkflow();\n        this.updateExecuteButton('Execute');\n        break;\n      case 'Delete':\n        diagram.remove();\n        break;\n      case 'Select':\n        diagram.tool = DiagramTools.MultipleSelect;\n        break;\n      case 'Pan':\n        diagram.tool = DiagramTools.ZoomPan;\n        break;\n    }\n  }\n\n  // save the current diagram in json format\n  public saveDiagram(): void {\n    const jsonData = this.diagram.saveDiagram();\n    const blob = new Blob([jsonData], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'Diagram.json';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }\n\n  // SYMBOL PALETTE\n  public palettes = [\n    {\n      id: 'BPMN',\n      expanded: true,\n      symbols: [\n        {\n          id: 'Start',\n          shape: { type: 'Bpmn', shape: 'Event' },\n          annotations: [{ content: 'Start' }],\n          tooltip: { content: 'Start', relativeMode: 'Object' },\n          constraints: NodeConstraints.Default | NodeConstraints.Tooltip\n        },\n        {\n          id: 'Decision',\n          shape: { type: 'Bpmn', shape: 'Gateway' },\n          annotations: [{ content: 'Decision' }],\n          tooltip: { content: 'Decision', relativeMode: 'Object' },\n          constraints: NodeConstraints.Default | NodeConstraints.Tooltip\n        },\n        {\n          id: 'Task',\n          shape: { type: 'Bpmn', shape: 'Activity' },\n          annotations: [{ content: 'Task' }],\n          tooltip: { content: 'Task', relativeMode: 'Object' },\n          constraints: NodeConstraints.Default | NodeConstraints.Tooltip\n        },\n        {\n          id: 'End',\n          shape: { type: 'Bpmn', shape: 'Event', event: { event: 'End', trigger: 'None' } },\n          annotations: [{ content: 'End' }],\n          tooltip: { content: 'End', relativeMode: 'Object' },\n          constraints: NodeConstraints.Default | NodeConstraints.Tooltip\n        }\n      ],\n      iconCss: ''\n    }\n  ];\n\n  public getSymbolInfo(symbol: NodeModel): SymbolInfo {\n    return { fit: true };\n  }\n  public onPaletteExpanding(args: any) {\n    args.cancel = true;\n  }\n\n  // function to enable or disable tool bar buttons based on editing mode\n  public applyModeState(isEditMode: boolean): void {\n    const buttonsToToggle = ['Select', 'Delete', 'Save'];\n    if (this.toolbar) {\n      this.toolbar.items.forEach((item) => {\n        if (buttonsToToggle.includes(item.id)) {\n          item.disabled = !isEditMode;\n        }\n      });\n\n      // Hide last separator in toolbar if palette is hidden\n      const lastSepIndex = this.toolbar.items.findIndex((item, idx) => item.type === 'Separator' && idx > 7);\n      if (lastSepIndex !== -1) {\n        this.toolbar.items[lastSepIndex].visible = isEditMode;\n      }\n\n      // Show/hide stencil palette\n      const paletteEl = document.getElementById(\"symbolPalette\");\n      if (paletteEl) {\n        paletteEl.style.display = isEditMode ? 'flex' : 'none';\n      }\n      this.diagram.tool = isEditMode ? DiagramTools.MultipleSelect : DiagramTools.ZoomPan;\n    }\n  }\n  public onToggleChange(args: any): void {\n    this.isEditMode = args.checked;\n    this.applyModeState(this.isEditMode);\n    this.tooltipContent = this.isEditMode ? 'Disable Editing' : 'Enable Editing';\n  }\n\n\n}","polyfills.ts":"import 'zone.js';","app/app.config.ts":"import { ApplicationConfig } from '@angular/core';\n\n export const appConfig: ApplicationConfig = { providers: [], };","index.html":"<!doctype html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"utf-8\">\n            <title>Window</title>\n            <base href=\"/\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n            <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n            <link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" >\n          </head>\n          <body class=\"ej2-new\"> \n\n              <!-- Google Tag Manager (noscript) -->\n              <noscript><iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-W8WD8WN\" height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe></noscript>\n              <!-- End Google Tag Manager (noscript) -->\n           <div hidden id=\"sync-analytics\" data-queue=\"EJ2 - Angular - Demos\"></div>\n            <app-root></app-root>\n          </body>\n        </html>","app.component.html":"<style>\r\n.control-section{\r\n    margin-top: 100px;\r\n}\r\n\r</style>\n<script src=\"script/diagram-common.ts\"></script>\n<style>\n  #DiagramtoolbarContainer {\n    display: flex;\n    align-items: center;\n    height: 62px !important;\n    width: 100% !important;\n    position: relative;\n  }\n\n  #Diagramtoolbar {\n    width: 80% !important;\n    height: 62px !important;\n  }\n\n  #DiagramtoolbarWithToggleSwitch {\n    width: 20% !important;\n    height: 62px !important;\n  }\n\n  #Diagramtoolbar .e-toolbar-item {\n    padding: 0px !important;\n  }\n\n  #DiagramtoolbarWithToggleSwitch .e-toolbar-item {\n    padding: 0px !important;\n  }\n\n  #symbolPalette {\n    overflow: hidden !important;\n    height: 100%;\n    display: flex;\n    align-items: center;\n  }\n\n  #symbolPaletteComponent_container {\n    border: none !important;\n  }\n\n  #symbolPalette .e-acrdn-header {\n    display: none;\n  }\n\n  #symbolPalette .e-acrdn-content {\n    padding: 0;\n    background-color: transparent !important;\n  }\n\n  #symbolPalette .e-remove-palette {\n    background-color: transparent !important;\n  }\n\n  #symbolPalette .e-accordion {\n    background-color: transparent !important;\n  }\n\n  #symbolPalette .e-accordion .e-acrdn-item.e-selected.e-select.e-active {\n    background-color: transparent !important;\n  }\n\n  #diagramContainer {\n    flex: 1;\n  }\n\n  #diagram {\n    width: 100%;\n    height: 100%;\n    border: 1px solid transparent;\n  }\n\n  #Diagram-switch-container {\n    z-index: 1000;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    position: absolute;\n    right: 0;\n    margin-right: 10px;\n  }\n\n  .Diagram-loading-indicator {\n    border: 4px solid #e6ffe6;\n    border-top: 4px solid green;\n    border-radius: 50%;\n    width: 12px;\n    height: 12px;\n    animation: spin 2s linear infinite;\n  }\n\n  .Diagramtick {\n    display: none;\n    animation: showTick 0.5s forwards;\n    width: 14px;\n    height: 14px;\n    padding: 1px;\n    line-height: 1;\n    color: white;\n    border-radius: 50%;\n    background-color: green;\n  }\n\n  .diagram-edit-label {\n    font-size: 14px;\n    margin-right: 6px;\n    color: inherit; /* inherits color from toolbar */ \n  }\n\n  @keyframes spin {\n    0% {\n      transform: rotate(0deg);\n    }\n\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n\n  @keyframes showTick {\n    0% {\n      opacity: 0;\n      transform: scale(0.5);\n    }\n\n    100% {\n      opacity: 1;\n      transform: scale(1);\n    }\n  }\n</style>\n<div class=\"control-section\">\n  <div id=\"DiagramtoolbarContainer\" class=\"db-toolbar-container\">\n    <ejs-toolbar id=\"Diagramtoolbar\" #Diagramtoolbar (clicked)=\"onToolbarClick($event)\" height=\"100%\" width=\"100%\" overflowMode=\"Popup\">\n      <e-items>\n        <e-item id=\"New\" text=\"New\" tooltipText=\"New Diagram\" prefixIcon=\"e-icons e-circle-add\"></e-item>\n        <e-item id=\"Open\" text=\"Open\" tooltipText=\"Open Diagram\" prefixIcon=\"e-icons e-folder-open\"></e-item>\n        <e-item id=\"Save\" text=\"Save\" tooltipText=\"Save Diagram\" prefixIcon=\"e-icons e-save\"></e-item>\n\n        <e-item type=\"Separator\"></e-item>\n\n        <e-item id=\"Execute\" text=\"Execute\" width=\"90\" tooltipText=\"Start Workflow\" prefixIcon=\"e-icons e-play\"\n          overflow=\"Show\"></e-item>\n        <e-item id=\"Reset\" text=\"Reset\" tooltipText=\"Reset View/State\" prefixIcon=\"e-icons e-reset\"\n          overflow=\"Show\"></e-item>\n        <e-item id=\"Delete\" text=\"Delete\" tooltipText=\"Delete Selected\" prefixIcon=\"e-icons e-trash\"></e-item>\n\n        <e-item type=\"Separator\"></e-item>\n\n        <e-item id=\"Select\" text=\"Select\" tooltipText=\"Select Tool\" prefixIcon=\"e-icons e-mouse-pointer\"\n          overflow=\"Show\"></e-item>\n        <e-item id=\"Pan\" text=\"Pan\" tooltipText=\"Pan Tool\" prefixIcon=\"e-icons e-pan\" overflow=\"Show\"></e-item>\n\n        <e-item type=\"Separator\"></e-item>\n\n        <e-item id=\"palette\" overflow=\"Show\">\n          <ng-template #template>\n            <aside id=\"symbolPalette\" [style.display]=\"editMode ? 'flex' : 'none'\">\n              <ejs-symbolpalette #symbolPalette id=\"symbolPaletteComponent\" width=\"100%\" height=\"50px\"\n                [palettes]=\"palettes\" [symbolHeight]=\"45\" [symbolWidth]=\"45\" [enableAnimation]=\"false\"\n                [getSymbolInfo]=\"getSymbolInfo\" (paletteExpanding)=\"onPaletteExpanding($event)\">\n              </ejs-symbolpalette>\n            </aside>\n          </ng-template>\n        </e-item>\n      </e-items>\n    </ejs-toolbar>\n    <ejs-toolbar id=\"DiagramtoolbarWithToggleSwitch\" #DiagramtoolbarWithToggleSwitch cssClass=\"toggle-toolbar\"\n      height=\"100%\">\n      <e-items>\n        <e-item id=\"EditToggle\" overflow=\"Show\">\n          <ng-template #template>\n            <div id=\"Diagram-switch-container\">\n              <ejs-tooltip [content]=\"tooltipContent\" position=\"TopCenter\" opensOn=\"Hover\">\n                 <div style=\"display: flex; align-items: center; height: 100%;\">\n                  <span id=\"editLabel\" class=\"e-toolbar-item-text diagram-edit-label\" style=\"font-size: 14px; margin-right: 6px;\">\n                    Edit\n                  </span>\n                  <ejs-switch id=\"switchMode\" [(checked)]=\"isEditMode\" (change)=\"onToggleChange($event)\">\n                  </ejs-switch>\n                </div>\n              </ejs-tooltip>\n            </div>\n          </ng-template>\n        </e-item>\n      </e-items>\n    </ejs-toolbar>\n    <input type=\"file\" #fileInput accept=\".json\" style=\"display: none\" (change)=\"onFileChange($event)\" />\n  </div>\n  <div>\n    <ejs-diagram #diagram id=\"diagram\" width=\"100%\" height=\"600px\" [scrollSettings]=\"scrollSettings\" [tool]=\"tools\"\n      [nodes]=\"nodes\" [connectors]=\"connectors\" [getNodeDefaults]=\"getNodeDefaults\"\n      [getConnectorDefaults]=\"getConnectorDefaults\" [selectedItems]=\"selectedItems\"\n      (onUserHandleMouseDown)=\"onUserHandleMouseDown($event)\" (selectionChange)=\"onSelectionChange($event)\"\n      (created)=\"onCreated()\">\n    </ejs-diagram>\n\n  </div>\n</div>","app.component.css":"","dependencies.json":"{\"@syncfusion/ej2-base\":\"*\",\"@syncfusion/ej2-angular-base\":\"*\",\"@syncfusion/ej2-diagrams\":\"*\",\"tslib\":\"^2.3.0\",\"@syncfusion/ej2-angular-diagrams\":\"*\",\"@syncfusion/ej2-navigations\":\"*\",\"@syncfusion/ej2-angular-navigations\":\"*\",\"@syncfusion/ej2-buttons\":\"*\",\"@syncfusion/ej2-angular-buttons\":\"*\",\"@syncfusion/ej2-popups\":\"*\",\"@syncfusion/ej2-angular-popups\":\"*\",\"@syncfusion/ej2-splitbuttons\":\"*\",\"@syncfusion/ej2-angular-splitbuttons\":\"*\",\"@syncfusion/ej2-inputs\":\"*\",\"@syncfusion/ej2-angular-inputs\":\"*\",\"@syncfusion/ej2-dropdowns\":\"*\",\"@syncfusion/ej2-angular-dropdowns\":\"*\",\"@syncfusion/ej2-circulargauge\":\"*\",\"@syncfusion/ej2-angular-circulargauge\":\"*\",\"@syncfusion/ej2-calendars\":\"*\",\"@syncfusion/ej2-angular-calendars\":\"*\",\"@syncfusion/ej2-lists\":\"*\",\"@syncfusion/ej2-angular-lists\":\"*\",\"@syncfusion/ej2-grids\":\"*\",\"@syncfusion/ej2-angular-grids\":\"*\",\"@syncfusion/ej2-charts\":\"*\",\"@syncfusion/ej2-angular-charts\":\"*\",\"@syncfusion/ej2-data\":\"*\",\"codemirror\":\"5.65.15\",\"marked\":\"0.3.19\",\"@types/codemirror\":\"0.0.56\",\"@types/marked\":\"0.3.0\",\"@angular/http\":\"*\",\"rxjs-compat\":\"*\",\"core-js\":\"2.6.9\",\"fuse.js\":\"^7.0.0\"}"}